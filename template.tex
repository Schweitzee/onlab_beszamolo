%                                             -*- coding: utf-8 -*-
% Mindenkinek csak javasolni tudjuk, hogy latex-et használjon.
% Szakdolgozatnál vagy diplománál már egyértelműen kijönnek az
% előnyei a Worddel szemben.  Ennek ellenére ez a sablon messze nem
% tökéletes.  Ha valamit javítanál benne, kérlek, küld vissza, hogy
% hallgatótársaid is profitáljanak belőle.  Köszönöm.

% További nehézséget okoz, hogy a népszerű latex disztribúciók nem
% tartalmazzák a legújabb változatát a magyar.ldf-nek.  A szükséges
% fájlokat a sablon mellé bemásoltuk, de le is tölthetőek innen:
% http://www.math.bme.hu/latex/
%
%
%
\documentclass[a4paper,oneside]{article}
\usepackage[margin=3cm]{geometry}
% =================================================================
% Magyar nyelvi támogatás
%------------------------
% ###################
% Nyelvváltó parancsok:
%\selectlanguage{english}
%\selectlanguage{magyar}
% rövid angol beszúrás:  \foreignlanguage{english}{some english text}
% határozott névelők generálása ``magyar'' babel-el:
% argumentum+megfelelő határozott nevelő: \az{},\Az{}
% csak a megfelelő határozott nevelő: \az*{}, \Az*{}
% címkék: \aref{}, \aref*{}, képletekhez \aref()
%        \Aref{}, \Aref*{}, képletekhez \Aref()
% oldalak: \apageref{}, \apageref*{}
%        \Apageref{}, \Apageref*{}
% idézetek: \acite, \acite*, \Acite, \Acite*
% ###################
\usepackage[english,magyar]{babel} %vegyes nyelvi támogatás a
% magyar helyesírás ellenőrzéshez (ispell) és elválasztáshoz
\selectlanguage{magyar}

%=================================================================
% direkt ékezetes karakter beírás támogatás
%-------------------------------------------
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{multirow} 
%================================================================
% Undorító dolog bitmappelt (Type III) betűtípust nézni a PDF-ben
% képernyőn. Az alapértelmezett Computer Modern font LaTex-ben
% bitmappelt, ezért használjunk Times fontot:
\usepackage{times}

%================================================================
% ha ábrát akarunk beemelni, akkor használjuk a graphicx/graphics
% csomagot és az \includegraphics[width=<width>]{abra.pdf} parancsot
\usepackage{graphicx} %for graphics
%kepek helye a gyokerhez(ehhez a file-hoz kepest) kepest
\graphicspath{{./figs/}}

%================================================================
% Kötelezően használjuk a hyperref csomagot, mert ezzel többek között 
%  kultúrált hyperlinkelt PDF-et lehet csinálni az alábbi
%  variációkban, különféle hyperref backend-ekkel:
%  pdflatex,dvipdfm,ps2pdf
% tapsztalataim szerint a MikTeX (Win32) a 'dvipdfm' konverzióval
% optimális  míg a teTeX (Linux/Solaris) jobb szereti a 'dvips' módszert
%------------------------------------
% pontosan egyet kommentezzünk be!!!!!!!
% értelemszerűen backend függően generáljunk dvi-ból PDF-et!!!
%------------------------------------
% A hyperref csomag az utolsó beolvasott csomag legyen, kivéve néhány
% problémás csomagot, pl. algorithm
%-----------
% ########################### FONTOS ###########################
% A hyperref hibásan működik a babel csomag 'magyar.ldf' fájljának
% 1.5-ös verziójánál korábbi változatával. 2004. februárjában a MikTeX
% és teTex disztribúciók még csak a v.1.4 verziót tartalmazták! A fájl
% aktuális verziója a BME Matematikai intézet LaTeX honlapjáról
% elérhető: http://www.math.bme.hu/latex/ 
% A lusták kedvéért a jelen sablon mellé is mellékelem:
% magyarlatex_0.01-2.tar.gz 
% ########################### FONTOS ###########################
%-----------
\usepackage[colorlinks=true]{hyperref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Itt kezdődik maga a dokumentum
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\input{onlabmacros} % Ez kell!!!
\markright{Schweitzer András Attila (TLEIB5)} % egyoldalas fejléc!!!
%--------------------------------------------------------------------
% fedlap
%--------------------------------------------------------------------
\begin{titlepage}
%bme logo 
 \begin{figure}[h]
    \centering
      \includegraphics[width=12cm]{bme_logo}
  \label{fig:bme_logo}
  \end{figure}
  \thispagestyle{empty}
  %cím generálás
  \onlabcim

% \begin{center}
%   \begin{tabular}{ p{3cm} p{5cm} }
%   
%   Készítette: & Schweitzer András Attila  \\
%   Neptun-kód: & TLEIB5  \\
%   Ágazat: & Intelligens hálózatok  \\
%   E-mail cím: & schweitzeraa16@gmail.com  \\
%   Konzulens: & Németh Felicián  \\
%   E-mail cím: & nemethf@tmit.bme.hu  \\
%   Konzulens: & Lévai Tamás  \\
%   E-mail cím: & levait@tmit.bme.hu  \\
%   
%   \end{tabular}
% \end{center}

 
  %\szerzo argumentumok: #1=Név, #2=Neptunkód, #3=szakirány, #4=email,#5 konzulens-1, #6 konzulens-1-email, #7 konzulens-2, #8 konzulens-2-email
  \onlabszerzo{Schweitzer András Attila}{TLEIB5}{Intelligens hálózatok}{schweitzeraa16@gmail.com}{Németh Felicián}{nemethf@tmit.bme.hu}{Lévai Tamás}{levait@tmit.bme.hu}
 
 
%\feladatcim argumentuma a feladat rövid, 1 soros címe
  \feladatcim{Többutas adatátvitel Media over Quic rendszerben (Media over Multipath QUIC)} 

  %\feladatmaga argumentuma a feladat 1-2 bekezdésnyi ismertetése
  \feladatmaga{
    A Media over QUIC (MoQ) egy új, még fejlesztés alatt álló protokollcsalád, 
    amelyet az IETF szabványosít. Egyik megvalósítása a LibQuicR, amely a feladat alapjául szolgál.
  A feladat maga pedig nem más, mint a LibQuicR könyvtár módosítása 
  oly módon, hogy az képes legyen kihasználni a 
  multipath (többutas) adatátviteli képességeket, amelyeket a PicoQUIC nevű, 
  QUIC protokollt megvalósító könyvtár biztosít. A munka során
  során a LibQuicR transzport rétegét úgy kell átalakítani, 
  hogy az egy kapcsolaton belül több hálózati útvonal létesítésére 
  és használatára legyen alkalmas a PicoQUIC multipath implementációján keresztül.

  A módosításokat követően a rendszer működését egy demonstrációval 
  igazoljuk: egy virtuális tesztkörnyezetben szimulált, több hálózati 
  interfésszel rendelkező kliensek segítségével történik az adatátvitel, 
  amely során aktívan használjuk a multipath képességeket. A demonstráció 
  során egy olyan forgatókönyvet vizsgálunk, ahol az egyik aktív 
  útvonalat szándékosan megszakítjuk. 
  A cél annak bemutatása, hogy a LibQuicR – az új multipath támogatással – 
  beavatkozás nélkül képes fenntartani az adatfolyam 
  továbbítását, minimális késleltetéssel és megszakítással.}

 
  %\tanevfelev argumentumok:
  % #1=Tanév (xxxx/xx alakban), #2=félév (pont nélkül!)
  
  \tanevfelev{2024/25}{II}
 
\end{titlepage} 

%==================================================================
\section{A laboratóriumi munka környezetének ismertetése,
     a munka előzményei és kiindulási állapota}
\label{sec:kornyezet}
% A munka  előzményei és kiindulási állapota
% \newpage
\subsection{Bevezető}
\label{sec:bevezeto}
%--------------------------------------------------------------------
Napjainkban az internetes adatforgalom túlnyomó részét különféle médiatartalmak – 
elsősorban videók és élő közvetítések – teszik ki. Egyes kutatások szerint 
szerint az internetes forgalom 65\%-a ilyen típusú tartalom lehet \cite{live_stats}. 
Ezek hatékony és megbízható továbbítása azonban komoly 
technológiai kihívást jelent, különösen akkor, ha a felhasználói élményt is 
figyelembe vesszük: az alacsony késleltetés, a megszakításmentes lejátszás 
és a biztonságos adatátvitel alapvető elvárások.

E kihívásokra jött létre válaszként a QUIC protokoll, amely UDP-alapú, alacsony 
késleltetésű, titkosított és megbízható adatátvitelt tesz lehetővé. Erre épülve 
fejlődik jelenleg a Media over QUIC (MoQ) szabvány, amely kifejezetten 
médiatartalmak hatékony továbbítását célozza a QUIC képességeit kihasználva.

Ezzel párhuzamosan a felhasználói eszközök – különösen a mobiltelefonok és 
laptopok – egyre gyakrabban rendelkeznek több hálózati interfésszel (például Wi-Fi és 5G). 
Mégis gyakran tapasztalható kapcsolatmegszakadás, hosszú töltési idők vagy éppenséggel 
elérhetetlenné váló szolgáltatások, ha az egyik kapcsolat megszakad vagy instabillá 
válik. A többutas adatátvitel lehetőséget kínál ezen problémák áthidalására azáltal, 
hogy párhuzamosan több hálózati útvonalat használ az adatok továbbítására, növelve 
ezzel a robusztusságot és az elérhető sávszélességet.

A jelen munka célja ezen két technológia – a médiatartalmakra optimalizált QUIC-alapú 
továbbítás és a multipath kommunikáció – egyesítése. A cél egy olyan rendszer bemutatása, 
amely képes több útvonalat kihasználva, élő adatfolyamot hatékonyan és megbízhatóan 
továbbítani. Ez nemcsak a hálózati erőforrások jobb kihasználását segíti elő, hanem 
hozzájárul a végfelhasználói élmény javításához is.

%--------------------------------------------------------------------

%<Mit kell tudni a feladatról, esetleges elméleti bevezető (nagyon értelemszerű dolgokat ne 
%definiáljunk, de jó, ha egy kicsit kontextusba kerül a témakör, miért fontos ez nekünk, 
%mi volt eddig, milyen megoldások jöhetnek szóba és miért emellett döntöttünk, milyen kari 
%nagyobb projektbe kapcsolódik ez), stb. Terjedelem max. 50\% beszámolónak.>
%Ennek a résznek az a szerepe, hogy az olvasó számára megmutassa az elvégzett munka tágabb környezetét.>

\subsection{Elméleti összefoglaló}

\subsubsection{A QUIC protokoll}
\paragraph{}
Az internetes multimédiaátvitel technológiai fejlődése során egyre 
nagyobb igény mutatkozik olyan protokollokra, amelyek képesek 
rugalmasan és hatékonyan kezelni a valós idejű adatfolyamokat, még 
változékony és megbízhatatlan hálózati körülmények között is. \cite{quic} A QUIC 
protokoll – mint UDP-alapú, titkosított és kapcsolatorientált 
transzportprotokoll – alapjaiban újraértelmezi a hálózati kommunikáció 
lehetőségeit, különösen olyan kiterjesztésekkel, mint a \emph{multipath} 
adatátvitel \cite{mp_quic}. A multipath képesség lehetővé teszi több párhuzamos hálózati 
útvonal (\textbf{path}) egyidejű vagy váltott használatát egyetlen logikai kapcsolat keretén 
belül, ami különösen hasznos mobil eszközök, redundáns hálózatok vagy edge 
hálózati környezetek esetén.

A QUIC protokoll és a HTTP/3 működésének vizsgálatára fejlesztették ki hozzá a qlog \cite{qlog} formátumot, amelynek célja,
hogy strukturált és gépileg olvasható formátumban rögzítse a QUIC kapcsolatok eseményeit és metrikáit.
Ez tulajodnképpen egy JSON-t generál a kapcsolat bármely végpontjában ami tartalmaz minden olyan adatot amely a 
kapcsolat során generálódik a QUIC rétegben, beleértve a csomagok küldését és fogadását,
a kapcsolat állapotát, a késleltetéseket és a hibákat is.


\subsubsection{QUIC multipath alapjai}
\paragraph{}
A multipath koncepció technikai alapja, hogy a QUIC kapcsolat során nemcsak egy, 
hanem több \textbf{path}
hozható létre, amelyeket a transzport réteg párhuzamosan vagy dinamikusan képes használni. 
Egy \emph{path} definíció szerint egy adott forrás-cél IP-cím és port kombináció, azaz 
különböző fizikai vagy logikai hálózati kapcsolatok reprezentálása. 
A projektben használt PicoQUIC könyvtár egy QUIC megvalósítás, amelynek fejlődő multipath 
támogatása lehetővé teszi, hogy egy kapcsolat során több ilyen path aktív legyen, és az 
alkalmazás (quic-et megvalósító rétegében egy belső algoritmus) meghatározza, 
hogyan ossza meg az adatforgalmat ezek között \cite{pico_git}.
\paragraph{}
PicoQUIC esetében a multipath kezelés alapvetően decentralizált és eseményvezérelt. 
A kapcsolat felépítése során egy adott interfészen elindított kapcsolat kiegészíthető 
további \textbf{PATH CHALLENGE / RESPONSE} (útvonal próba / útvonal válasz) üzeneteken keresztül feltérképezett 
útvonalakkal. Ha egy új path válik elérhetővé (például egy új IP-cím vagy interfész 
aktiválódik), a rendszer felismeri azt, és lehetőséget biztosít az adatküldés ezen 
az útvonalon történő elindítására. A path-ek állapotát folyamatosan figyeli a protokoll 
(RTT, veszteség, állapotváltozás), így lehetővé válik az útvonalak közötti dinamikus 
váltás vagy forgalommegosztás a kapcsolatok megszakítása nélkül. Ez különösen 
fontos valós-idejű alkalmazásokban, mivel lehetővé teszi a megszakítás nélküli adattovábbitást, 
még hálózati hiba vagy mobilitás esetén is.

\subsubsection{A Media over QUIC (MoQ) protokoll}
\paragraph{}

A Media over QUIC (MoQ) egy új, még fejlesztés alatt álló protokollcsalád \cite{moq_draft}, 
amely a QUIC nyújtotta lehetőségekre építve biztosít alacsony késleltetésű, 
valós idejű médiatovábbítást. A MoQ rendszerében a szerepkörök három alapvető 
típus köré szerveződnek: a \textbf{Publisher} (szolgáltató) az, aki a médiatartalmat (például 
videó vagy hangfolyam) létrehozza és továbbításra bocsátja, a \textbf{Subscriber} (fogyasztó)
a végponti fogyasztó, aki ezt a tartalmat fogadja és feldolgozza/lejátsza, míg a \textbf{Relay} (továbbító)
köztes szereplőként funkcionál, amely a számára elérhető tartalmat hirdeti és 
továbbítja más résztvevők felé, jellemzően a késleltetés, terheléselosztás 
és elérhetőség optimalizálása érdekében. 
Ezek a szereplők struktúrált MoQ adatfolyamokon keresztül kommunikálnak egymással, amelyek sávokból
(\emph{track}) azon belül pedig objektumokból(\emph{object}) épülnek 
fel, lehetővé téve a médiatartalom rugalmas azonosítását és replikációját.

\paragraph{}
A kidolgozás alatt álló szabvány szerint egy MoQ-alapú rendszerben a relay képes 
egyszerre több publisher és subscriber felé is kapcsolatot fenntartani, 
és akár multicast-szerű módon továbbítani a médiatartalmat. 
A hálózati topológia e szerepkörök között rengetegféle lehet, mivel 
a relayek közötti kapcsolat is támogatva van ami lehetővé teszi
a tartalom replikációját és elosztását a különböző relayek között. 
Ezáltal a gazdag struktúrabeli opciók lehetőséget biztosítanak a tartalom dinamikus 
és optimalizált terjesztésére, azonban egyben igényli azt is, hogy a transzport 
réteg rugalmasan tudjon alkalmazkodni a változó hálózati viszonyokhoz – például 
egy útvonal meghibásodásához, vagy új alternatív útvonal megjelenéséhez.

\subsubsection{Multipath célja a MoQ-ban}
\paragraph{}
A multipath működés bevezetése ebbe az architektúrába jelentős előnyt nyújthat, 
különösen olyan eszközök esetén, amelyek egyszerre több hálózati interfésszel 
rendelkeznek (például Wi-Fi és mobil adatkapcsolat szimultán használata). A relay-ek és végpontok 
(subscriber, publisher) több interfésszel rendelkező környezetben 
történő működése során a multipath támogatás nemcsak a redundanciát növeli, hanem 
lehetőséget biztosít egyfajta \textbf{hálózati adaptivitásra is}, amely révén például 
a relay automatikusan kiválaszthatja a legjobb elérhető útvonalat egy adott irányba. 
Ez az architektúra ideális alapot teremt olyan rendszerek számára, ahol fontos a magas 
rendelkezésre állás, az alacsony késleltetés és az automatikus hibatűrés.

A MoQ protokoll jelenlegi állapota még fejlesztés alatt áll, és jelenleg egyik implementáció
sem támogatja a multipath képességeket.

Bár más MoQ megvalósítások is léteznek, azért a LibQuicR könyvtárra esett a
választás, mert a QUIC protokollt a PicoQUIC könyvtár segítségével implementálja, amely
jelenleg is folyamatosan bővül, és multpath támogatása is követi a legújabb szabványosítási irányokat.

\subsection{A munka állapota, készültségi foka a félév elején}
\label{sec:munka-allap-kesz}
\paragraph{}
A munka félév kezdeti állapota röviden összefoglalható azzal, 
hogy saját tapasztalatom nem volt sem a QUIC protokollal, sem a LibQuicR
kódjával kapcsolatban, valamint a téma is új, tehát nem volt mire építeni.

\newpage
%==================================================================
\section{Az elvégzett munka és az eredmények ismertetése}
\label{sec:az-elvegzett-munka}


\subsection{A fejlesztés és elemzés lépései egy multipath demonstrációhoz}
\label{sec:a-munkam-ismert}
%--------------------------------------------------------------------

\subsubsection{Mininet szimulációs környezet}

 \paragraph{}

 Első sorban szükséges volt egy hálózat virtualizálására alkalmas környezet,
amely lehetővé teszi a különböző hálózati topológiák és viszonyok szimulálását, 
hiszen csak egy kontrollált környezetben 
lehet érdemben tesztelni a multipath működést. 
E célból a Mininet nevű eszközre esett a választás, mivel a használatához szükséges 
tudás elsajátítása nem igényelt sok időt.

A Mininet segítségével könnyen létrehozhatók virtuális gépek (továbbiakban hostok vagy h1/h2/h..), 
amelyek a futtató gépen létrehozott hálózati névterek, amelyeken virtuális
hálózati interfészeket és azokhoz hálózati konfigurációt rendelhetünk.
Ezekben a névterekben lehet futtatni a tesztelni és megfigyelni kívánt programokat.
A Mininet emellett lehetővé teszi a hálózati topológia 
szimuláció közbeni megváltoztatását is, így kapcsolatok megszűnését 
is könnyen szimulálhatjuk vele. \cite{mininet}

Az alábbi topológiát hoztam létre a Mininet segítségével, amellyel a multipath működését teszteltem (1. ábra):

\begin{figure}[h]
  \centering
    \includegraphics[width=15cm]{topo1}
\caption{A Mininetben létrehozott topológia \cite{drawio}}
\end{figure}
 
Ahogy említettem a h1, h2, h3 jelölik a hostokat, s0-s5 jelölik a switch-eket, és r0 jelöli a routert.
h1 három interfésszel rendelkezik, egyenként csatlakozik a s0, s1 és s2 switch-ekhez, azok pedig a r0 routerhez.
Hasonlóan h2 is, csak egy interfésszel, a h3 pedig kettővel csatlakozik.

A hostok és a router között azért van szükség switch-ekre,
mert a kapcsolatok szimuláció közbeni megszakítása problematikus, ha a megváltoztatott kapcsolat közvetlenül a host-okhoz csatlakozik.
Így az alábbi topológián egy switch és a router közötti kapcsolat megszakításával könnyen lehet szimulálni a kapcsolat megszakadását.

Címzés szempontjából a hostok eltérő alhálózatokban vannak, (a h1-nek még emellett 
mindhárom interfésze eltérő alhálózatban van, hogy az alapértelmezett átjáró eltérő lehessen, ezzel pontosabban szimulálva a valós környezetet),

\paragraph{}
A munkát és a tesztelést felgyorsítva mindezt egy Python szkript segítségével automatizáltam, 
amely a mininet API-ját használja a virtuális gépek és kapcsolatok létrehozására, konfigurálására, kezelésére, beleértve
a hostokon futtatott demonstrációs programokat és a Wireshark csomagelkapást is.
Tehát egy script futtatásával pillanatok alatt megfigyelhető a kívánt program működése.

\subsubsection{Megismerkedás a PicoQUIC könyvtárral}

\subparagraph{}
A féléves munka kezdetén első célom az volt, 
hogy alaposan megismerjem a PicoQUIC könyvtárat, mivel ez képezte a későbbi 
fejlesztések technikai alapját. A megismerés első lépése a \textbf{picoquicdemo} példaprogram
tanulmányozása és futtatása volt, ami segített megérteni a könyvtár felépítését, 
működését, de különösen a multpath kezelés módjait.

Maga a pcioquicdemo felépítése elég egyszerű, olyan értelemben hogy ez egy darab C fájl, amely a PicoQUIC függvényeit használja, 
és a szerver, valamint a kliensek funkcióit is ellátja egyaránt. 

Sajnos pont emiatt az átláthatóságot nem feltétlen egyszerűsíti meg, de összességében 
a munka során kiderült, hogy két dolog szükséges a multipath működéshez:

\begin{itemize}

  \item a kezdeti multipath negotiation (egyeztetés) – ami arra szolgál, hogy a két fél közötti első
  kapcsolat felépítésekor megegyezzenek az összes többi transzport paraméter mellett abban is, 
  hogy mind a két fél támogatja-e a többutas kapcsolatot

  \item illetve az "extra" útvonalak tényleges kiépítése

\end{itemize}

Ezek körül az utóbbit megvalósító kódrészletek könnyen fellelhetőek, mivel ezen a téren a program sok fajta opciót biztosít, 
amelyek közül a legegyszerűbb eshetőség az alapszintű multipath, amikor több interfész használatával
több útvonalat alakítunk ki, amelyeket a PicoQUIC könyvtár automatikusan kezel.

Jelenlegi munka szempontjából ez az egyszerű multipath a leginkább releváns,
mivel amíg az nem működik megfelelően, addig a komplexebb multipath forgatókönyvek nem is igazán tesztelhetők/használhatók.
Szerencsére az ezt ellátó kódrészlet a picoquicdemo-ban jól elkülönül, így jó alapot is képzett
a LibQuicR könyvtárban való implementálásához.

\subsubsection{Működés elemzésének módjai}

\subparagraph{}

Munkám során elég korán előjött a kérdés, hogy hogyan tudom a PicoQUIC működését elemezni, mivel
a tényleges működést nehéz folyamatában nyomon követni, hasznos lenne PicoQUIC kapcsolatot menedzselő adatfolyamot is látni.

A PicoQUIC rengeteg funkciót és metrikát biztosít a működés elemzésére, 
első sorban a qlog fájlok generálása lenne a leginkább logikus lépés, és
a protokoll alapszintű működésének megértése szempontjából valóban hasznos 
a qlog, de nem minden esetben elegendő, mivel a QUIC protokoll
sokféle eseményt és metrikát generál, amelyek közül sok nem feltétlenül releváns a 
multipath működés szempontjából és maga a multipath is megnehezíti mivel az egyetlen 
qlog vizualizáló amit találtam az a qvis \cite{qvis} \footnote{qvis: webes alkalmazás, amely a qlog 
fájlok vizualizálására szolgál, és sajnos a multipath használata könnyen eltorzítja a két oldal 
kapcsolatának a szinkronizációját.} volt, ami sajnos nem tudja könnyen és átláthatóan kezelni a multipath eseményeket, 
így ezzel nem tudtam megfelelően elemezni a kapcsolatokat.

\paragraph{}
Ezt a nehézséget kiváltandó a Wireshark program választása sokkal hasznosabbnak bizonyult, mivel
a QUIC protokollt is támogatja, illetve tanulmányaim során is találkoztam már vele. 
Azonban ez olyan kihívást állít a qlog-gal szemben, hogy míg a 
qlog fájlokat a program maga generálja, tehát a titkosítást ki tudja kerülni, 
addig a Wireshark magukat a hálózati interfészen megjelenő csomagokat rögzíti, 
így a QUIC csomagok titkosítása megnehezítette a folyamatot, főleg a multipath 
miatt, mivel a másodlagos útvonalon küldött és fogadott csomagokat a Wireshark 
nem tudja hozzákötni automatikusan az első útvonal interfészén létrejött kapcsolat titkosított csomagjaihoz.

A PicoQUIC beépítetten támogatja a SSL keylog fájlok generálását a "SSLKEYLOGFILE" környezeti változó 
beállításával, ami segítségével fel lehet oldani a quic által használt tls titkosítást,
így a Wireshark képes dekódolni a csomagokat, és megjeleníteni azok 
tartalmát (legalábbis a kapcsolat kezeléséért felelős quic réteg szempontjából).

Ez a megoldás lehetővé tette számomra, hogy a Wireshark segítségével generált 
pcapng fájlokat átkonvertáljam dekódolt formátumra az alábbi paranccsal:
\begin{verbatim}
  editcap --inject-secrets tls,<keylog_file> <input_pcap_file> 
    <output_pcap_file>
\end{verbatim}
Ez a parancs a Wireshark által generált TLS titkosítást használó QUIC 
csomagokat tartalmazó pcapng fájlokat dekódolja, a keylog fájl segítségével, így azok bármilyen kontextusban, a keylog fájl nélkül megtekinthetőek
és elemezhetőek egy Wireshark programban.


\subsubsection{LibQuicR felépítése és átalakítása}
\paragraph{}

A LibQuicR könyvtár természetesen egy nagyobb volumenű kihívás mint a picoquicdemo program 
megértése, mivel amíg az utóbbi egy darab C fájl, ami direkt használja a PicoQUIC könyvtárat,
addig a LibQuicR egy sokkal komplexebb struktúrával rendelkezik, amelyben a PicoQUIC könyvtár sokkal kevésébb közvetlenül van jelen.
Ennek ellenére pont azért, mert egy jelentősen nagyobb struktúráról van szó, szükségszerűen sokkal 
jobban elkülönülnek a különböző funkciók, így a PicoQUIC API-ját használó kódrészletek is.

Tulajdonképpen 3 funkciót kellett implementálni a LibQuicR könyvtárban,
amelyek a multipath működéshez kapcsolódnak:
\begin{enumerate}
  \item CLI argumentumok kiegészítése multipath specifikus lehetőségekkel

  \item a multipath negotiation (egyeztetés) – ami arra szolgál, hogy a két fél közötti első
  kapcsolat felépítésekor megegyezzenek az összes többi transzport paraméter mellett abban is, 
  hogy mind a két fél támogatja-e a többutas kapcsolatot

  \item a másodlagos útvonalak tényleges kiépítése

\end{enumerate}

Nyilvánvalóan ebből a második és harmadik megegyezik a korábban PicoQUIC-nél említettekkel, mivel ezek elengedhetetlenek a multipath működéshez,
de ahhoz, hogy ezt érdemben lehessen használni is, szükséges volt a CLI argumentumok kiegészítése is.
Ezt a picoquicdemo-ban használatos argumentumokhoz hasonlóan 
valósítottam meg, mivel ha már PicoQUIC-re alapozik a LibQuicR, és maga a fejlesztésem pedig annak a 
multipath demonstrálására szolgáló demó programjára alapozik, akkor a CLI argumentumoknak hasonlósága logikus lépés.

Relay esetén ez a CLI argumentumok kiegészítése csak egy extra argumentumot jelentett:
\begin{verbatim}
  -m, --multipath
\end{verbatim}
Ez egy szimpla kapcsoló (nem fogad extra paramétert), amely oly módon engedélyezi a multipath támogatást, hogy amikor létrejön a relay objektum QUIC traszportért felelős része,
akkor azt úgy inicializálja, hogy egy bejövő kapcsolat esetén a transzport paraméterek egyeztetésénél a saját paraméterei között szerepeljen a multipath támogatás is.

Végponti kapcsolat esetén ez két kiegészítést jelentett:
\begin{itemize}
  \item 
  \begin{verbatim}
    -m, --multipath
  \end{verbatim}

  \item \begin{verbatim}
    -a "...", --alt_ifaces "..."
  \end{verbatim}
\end{itemize}

Itt természetesen a multipath kapcsoló ugyanúgy működik mint a relay esetén,
de emellett szükséges volt egy új argumentum is, amely lehetővé teszi a felhasználó számára, hogy megadja a másodlagos interfészeket,
amelyeken a multipath harmadik szükséges elemét, a másodlagos útvonalakat kiépíti. Ehhez szüksége van paraméterekre, amelyek a másodlagos interfészeket
tartalmazzák, itt is a picoquicdemo-val azonos formátumot használtam, tehát a következő formátumot várja:
\begin{verbatim}
  -a "<ip-cím>/<interfész száma>,<ip-cím>/<interfész száma>,..."}
\end{verbatim}
Például a h1 host esetén ez az alábbi módon néz ki: "192.168.1.100/3,192.168.2.100/4". Látható, hogy az alapértelmezett ip címre nincs 
szüksége, mert azon már elkezdődött a kapcsolat, és csak azokat az interfészeket kell megadni, amelyeken a másodlagos útvonalakat kiépíti. 

A megfelelő ip-cím/interfész párokat az 
\begin{verbatim}
  ip addr show
\end{verbatim}
paranccsal lehet lekérdezni linuxon, amely megjeleníti a host interfészeinek ip-címét és számát.

Az eltérés a relay és a végponti kapcsolat között abban rejlik, hogy míg a relay fogadja a bejövő kapcsolatokat, addig a végponti kapcsolat esetén önállóan,
a kapcsolat létrejötte után küldd PATH CHALLENGE üzeneteket a másodlagos interfészeken, 
hogy azok is elérhetővé váljanak a kapcsolat számára (amennyiben a multipath negotiation sikeresen megtörtént).
Relay esetén több interfész használatát nem implementálja jelenleg a munkám.

\paragraph{}

A multipath negotiation megvalósulásához ki kellett egészíteni a LibQuicR-ben
használt adatstruktúrákat, hogy eljussanak a multipath és az interfész információk
arra a szintre, ahol a PicoQUIC könyvtár API-ját használja a program, valamint 
a PicoQUIC transzport objektum konstruktorát 
kellett kiegészíteni, és a transzport paraméterek inicializálásakor a mulitpath paraméter mellett az 
\begin{verbatim}
  initial_max_path_id
\end{verbatim}
változót kellett beállítani, hogy kapcsolat létrehozása után tudjon kezelni több útvonalat is.

\paragraph{}

A többi útvonal kiépítése gyakorlatilag megegyező módon működik, mint a picoquicdemo esetén. A PicoQUIC 
\begin{verbatim}
  packet_loop_v3()
\end{verbatim}
függvénye minden egyes csomag feldolgozása után meghív egy callback függvényt, amely a LibQuicR könyvtárban van 
implementálva, és ebben történik meg – ha minden körülmény adott, tehát kliensről van szó, 
multipath engedélyezett, és addig a pontig még nem volt új útvonal próbálva – hogy a másodlagos interfészeken PATH CHALLENGE üzeneteket küldjön.
Ebben a callback függvényben történik egy segédfüggvény segítségével a másodlagos interfészeket tartalmazó sztring feldolgozása is, amely logikailag
ugyancsak azonos módon működik mint a picoquicdemo esetén.


\subsubsection{Elvégzett munka eredményei}
\paragraph{}

Módosításaim eredményeként a bemutatott környezetben működik a multipath
kapcsolat, amely a másodlagos interfészeken keresztül adatokat küldeni és fogadni, továbbá valamely útvonal megszakadása esetén
minimális késleltetéssel képes a másodlagos interfészen folytani az adatátvitelt.
Maga az adatátvitel időbélyegek másdopercenkénti küldését jelenti, ami egy beépített módja a LibQuicR demó programjának.

\begin{figure}[h]
  \centering
    \includegraphics[width=14cm]{bmon1}
\caption{Interfész aktivitás 3 aktív útvonallal}
\end{figure}

2. ábra képén látható, hogy 3 aktív interfészen keresztül van folyamatos adatátvitel, majd a 3. ábrán 
már látható, hogy a nullás indexű interfészen nem folyik adat, mivel itt az ahhoz kapcsolódó switch és a router közötti kapcsolatot megszakítottam.
Ezért a másodlagos interfészeken keresztül folytatódik az adatátvitel. Ezek nem csak azt bizonyítják, hogy a multipath 
implementáció kezeli a kapcsolatszakadást, de azt is, hogy akár 3 interfészt is tud hasznosítani.


\begin{figure}[h]
  \centering
    \includegraphics[width=14cm]{bmon2}
\caption{Interfész aktivitás 2 aktív útvonallal}
\end{figure}

Majd pedig a 4. ábra képén látható, hogy az egyes indexű interfészen is leállt az adatátvitel (ugyancsak 
kapcsolatszakadás miatt), de a kettes indexű interfész még mindig képes folytani a kapcsolatot.

\begin{figure}[h]
  \centering
    \includegraphics[width=14cm]{bmon3}
\caption{Interfész aktivitás 1 aktív útvonallal}
\end{figure}

\pagebreak
Fontos megjegyezni, hogy a relay minimális kódváltoztatással képes minden alábbi szituációban működni:
\begin{itemize}
  \item subscriber és publisher is 1-1 intefészen kapcsolódik
  \item csak subscriber vagy csak publisher kapcsolódik egynél több interfészen
  \item mind a subscirber és a publisher is több interfészen kapcsolódik
\end{itemize}

Illetve érdekes azt is megjegyezni, hogy a korábban említett 
\begin{verbatim}
  initial_max_path_id
\end{verbatim}
változó a kódban 2-re van állítva, ha multipath környezetben indul el a program,
de ez nem korlátozza le kapcsolatonként két interfész használatára sem a relayt, sem pedig a 
subscribert vagy a publishert, mint látható a 2. ábrán, ahol 3 interfész van aktívan használva.

\subsection{Összefoglalás}
\label{sec:osszefoglalas}

\subsubsection{Féléves feladat összefoglalása}
\paragraph{}
A félév során a Quic feletti médiaátvitelt megvalósító LibQuicR könyvtárban implementáltam 
egy kezdetleges multipath funckionalitást, amely lehetővé teszi a relay és a végponti 
kapcsolatok számára, hogy több interfészen keresztül kommunikáljanak egymással, valamint ezt demonstráltam egy Mininet alapú 
virtuális környezetben.


\subsubsection{Feladat érdekessége}
\paragraph{}

Ez az első ilyen implementáció MoQ architektúrában, és bár kezdetleges multipath funckionalitást szolgáltat,
de látható belőle, hogy rengeteg lehetséges irány van a továbbfejlesztésére, amelyek mindegyikéhez jó alapot 
képez a félév során elvégzett munka. Lehetséges folytatásai a projektnek:
\begin{itemize}
  \item relay és végpont esetén a másodlagos interfészek használata
  \item picquicdemo programban megtalálható egyéb multipath lehetőségek implementálása
  \begin{itemize}
    \item kapcsolati azonosítók megújítása
    \item NAT rebinding \footnote{A NAT rebinding (vagy NAT kapcsolat újtársítás) egy olyan jelenség, 
    amikor a hálózati címfordító (NAT) eszköz új külső IP-cím–port párost rendel a klienshez, 
    például újracsatlakozás után} (NAT kapcsolat újratársítás) lehetősége
    \item azonos címről, de másik porttal új útvonal létrehozása
    \item kapcsolat teljes migrációja a másodlagos interfészek egyikére
  \end{itemize} 
  \item relay és relay közötti kapcsolatban multipath használata
  \item olyan demó program készítése amely valós médiaátvitelt végez multipath használatával (videó streamelés)
\end{itemize}

\subsubsection{A munka során használt eszközök}
\paragraph{}
A Wireshark és a Mininet programok sok segítséget nyújtottak a munka során, mind a protokollok 
megismerésében és megértésében, mind pedig a munka és azon belül is a tesztelés automatizálásában, de ezeken 
felül haladva a világgal, próbáltam nagy nyelvi modelleket is hasznosítani a munka során, mint például a ChatGPT, vagy a GitHub Copilot,
amelyek sok esetben segítettek a kód megértésében, de ugyanakkor sok esetben megmutatták, hogy mik a határaik, mivel 
ezek az eszközök se tudják teljes egészében átlátni a projekt struktúráját, emiatt gyakran csak tág keretek között tudtak tippeket adni, de konkrét
irányokat nem tudtak mutatni. Így természetesen a legtöbbször manuálisan kellett felfedeznem a kapcsolódási pontokat a LibQuicR és a picoQUIC között,
aminek eredményeként sokkal jobb rálátást kaptam a két könyvtár közötti kapcsolatra.

\subsubsection{Legfontosabb eredményei a munkának}
\paragraph{}

Két lényeges eredménye van a munkának:
\begin{itemize}
  \item A LibQuicR könyvtárban a multipath működésének kezdetleges implementálása
  \item SSL keylog fájl generálását beépítettem a LibQuicR könytár általam módosított verziójába
\end{itemize}
Ezeket a félév végén egy GitHub pull request keretében szeretném megosztani a LibQuicR könyvtár fejlesztőivel,
hogy a könyvtár további fejlesztése során egyrészt létrejöjjön egy multipath fejlesztési irány is a projektben, másrészt hogy
a picoQUIC könyvtárral való együttműködést is megkönnyítse a LibQuicR könyvtár fejlesztői számára.

\subsubsection{Egyéb következtetések amelyekre a munka során jutottam}

A Wireshark használata során érdekes kérdés merült fel a multipath PicoQUIC implementálásával kapcsolatban,
mégpedig, hogy a kapcsolat útvonalait nem feltétlen kezeli az IETF Multipath draftja szerint, mivel adott útvonal kapcsán útvonal szakadás 
esetén nem láttunk PATH ABANDON üzenetet, ami arra szolgálna, hogy egy már nem működő útvonalat inaktívvá nyilvánítson mind a két fél számára.
Azonban olyan érdekes jelenség is előfordult, hogy A és B útvonal esetében A útvonal megszakítása után B útvonalon ment tovább az adatátvitel,
de ha A útvonal újra aktívvá vált, akkor nem használta újra azt, és ezután B útvonal megszakítása után sem váltott vissza A útvonalra. Viszont mi ezt még inkább
érdekessé teszi, hogy B útvonalat újra aktiválva az adatátvitel folytatódott. Tehát a PicoQUIC multipath implementációja nem feltétlenül
kezel minden esetet a draft szerint, de ez nem feltétlenül probléma jelenleg, mivel még ez is fejlesztés alatt áll, illetve ez is kijelöl egy lehetséges 
irányt a projekt folytatására.


\newpage
 
%==================================================================
\section{Irodalom, és csatlakozó dokumentumok jegyzéke}
\label{sec:irod-es-csatl}

\begin{thebibliography}{9}
\label{sec:tanulm-irod-jegyz}

\bibitem{live_stats} Douglas Karr, \emph{Live Streaming Trends and Statistics (2024)}, 
\url{https://martech.zone/live-streaming-trends-statistics/}

\bibitem{quic} J. Iyengar and M. Thomson.
\newblock QUIC: A UDP-Based Multiplexed and Secure Transport.
\newblock RFC 9000, IETF, May 2021.\\
\url{https://www.rfc-editor.org/rfc/rfc9000}

\bibitem{mp_quic} QUIC Working Group, \emph{Multipath Extension for QUIC, draft-ietf-quic-multipath-14, 2025. apr. 24.}, \url{https://datatracker.ietf.org/doc/draft-ietf-quic-multipath/14/}

\bibitem{pico_git} Christian Huitema / Private Octopus Inc., \emph{PicoQUIC GitHub repository}, \url{https://github.com/private-octopus/picoquic}

\bibitem{moq_draft} IETF, \emph{Media over QUIC Transport, 2025. apr. 28.}, \url{https://datatracker.ietf.org/doc/draft-ietf-moq-transport/11/}

\bibitem{mininet}
Bob Lantz, Brandon Heller, and Nick McKeown.
\newblock A network in a laptop: rapid prototyping for software-defined networks.
\newblock In \emph{Proceedings of the 9th ACM SIGCOMM Workshop on Hot Topics in Networks (Hotnets-IX)}, pages 19--24, Monterey, California, 2010.
\newblock Association for Computing Machinery. \url{https://doi.org/10.1145/1868447.1868466}.

\bibitem{drawio} Draw.io segítségével készült ábra, \url{https://app.diagrams.net/}

\bibitem{libquicr} Quicr, \emph{LibQuicR GitHub repository}, \url{https://github.com/Quicr/libquicr}

\bibitem{qlog}Robin Marx.
\newblock qlog: A standardized schema for logging and visualizing QUIC events.\\
\url{https://github.com/quiclog/qlog}

\bibitem{qvis}Robin Marx.
\newblock qvis: A web-based tool for visualizing qlog files.\\
\url{https://qvis.quictools.info}

\end{thebibliography}

%==================================================================
\subsection{A csatlakozó dokumentumok jegyzéke}
\label{sec:csat-irod}

Saját multipath implementációm GitHub repository-ja: \url{https://github.com/Schweitzee/libquicr/tree/multipath}

SSL keylog fájl generálásához szükséges módosítások: \url{https://github.com/Schweitzee/libquicr/tree/ssl-keylog}

\end{document} 

%%% Local Variables: 
%%% mode: latex 
%%% TeX-master: t 
%%% End:

